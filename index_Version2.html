<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Jump Runner — Single-file PWA Mini Game</title>
  <meta name="theme-color" content="#0b3d91">
  <style>
    :root{
      --bg1:#87ceeb; --bg2:#bde7ff; --panel:#ffffffcc; --accent:#1f6feb; --muted:#023047;
    }
    html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;background:linear-gradient(var(--bg1),var(--bg2) 60%, #fff 100%);}
    #wrap{min-height:100%;display:flex;align-items:center;justify-content:center;padding:18px;}
    .card{position:relative;border-radius:12px;padding:12px;background:var(--panel);box-shadow:0 10px 30px rgba(11,61,145,0.12);}
    canvas{background:linear-gradient(#87ceeb,#def7ff 60%,#fff 100%);display:block;border-radius:8px;border:6px solid #2b6cb0;box-shadow:0 8px 20px rgba(0,0,0,0.14)}
    #hud{position:absolute;left:50%;transform:translateX(-50%);top:10px;color:var(--muted);font-weight:700;padding:6px 12px;border-radius:10px;background:rgba(255,255,255,0.92);box-shadow:0 6px 16px rgba(0,0,0,0.06)}
    #controls{display:flex;gap:8px;align-items:center;margin-top:10px;flex-wrap:wrap;justify-content:center}
    .btn{background:var(--accent);color:white;padding:8px 12px;border-radius:8px;text-decoration:none;border:none;cursor:pointer;font-weight:700}
    .secondary{background:#fff;border:1px solid #e6eefc;color:var(--muted)}
    #settings{display:flex;gap:8px;align-items:center;background:rgba(255,255,255,0.9);padding:8px;border-radius:8px}
    input[type="text"]{padding:6px 8px;border-radius:8px;border:1px solid #cfe4ff;width:260px}
    .small{font-size:12px;color:#234;}
    .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:40}
    .overlay-card{background:#000;color:#fff;padding:22px;border-radius:12px;text-align:center;max-width:92%;box-shadow:0 20px 60px rgba(0,0,0,0.6)}
    .big-link{display:inline-block;margin-top:14px;padding:12px 18px;border-radius:10px;background:#1f6feb;color:#fff;text-decoration:none;font-weight:800}
    footer{margin-top:8px;text-align:center;color:#234;font-size:13px}
    @media(max-width:520px){ canvas{width:340px;height:170px} input[type="text"]{width:160px} }
  </style>
  <!-- manifest will be created on load (single-file PWA) -->
</head>
<body data-end-link="https://example.com">
  <div id="wrap">
    <div class="card" style="width:960px;max-width:96vw">
      <div id="hud">Jump to avoid obstacles — Reach the flag!</div>
      <div style="display:flex;align-items:center;gap:12px;flex-direction:column">
        <canvas id="game" width="900" height="220" aria-label="Jump runner game"></canvas>

        <div id="controls">
          <div id="settings">
            <label class="small" for="endLink">End link:</label>
            <input id="endLink" type="text" placeholder="https://your-target.example" />
            <button id="saveLink" class="btn secondary">Save</button>
            <button id="randomize" class="btn secondary">Randomize Level</button>
          </div>

          <button id="fullscreen" class="btn">Fullscreen</button>
          <button id="playAgain" class="btn secondary">Restart (R)</button>
        </div>

        <footer class="small">Controls: Space / ↑ or Tap. Sound on. Installable PWA. Reach the goal in ~20s.</footer>
      </div>
    </div>
  </div>

<script>
(() => {
  // CONFIG (tweaked for better jumpability & smaller obstacles)
  const goalDistance = 2000;         // world pixels to goal
  const targetDurationMs = 19000;    // ~19s to reach goal (faster character)
  const speed = goalDistance / targetDurationMs; // px per ms
  const groundY = 170;
  const gravity = 0.0016;            // px / ms^2 (slightly lower gravity)
  const jumpVelocity = -0.7;         // stronger jump
  const playerX = 120;

  // Player
  const player = {
    x: playerX,
    y: groundY - 36,
    width: 28,
    height: 36,
    vy: 0,
    onGround: true,
    color: '#ffb703'
  };

  // Obstacles: made smaller
  let obstacles = [];
  const minGap = 110;
  const maxGap = 260;
  const obstacleCount = 12;

  function generateObstacles(seedRandom=false) {
    obstacles = [];
    let pos = 480;
    for (let i = 0; i < obstacleCount; i++) {
      const w = 12 + Math.round(Math.random()*24);            // 12 - 36
      const h = 16 + Math.round(Math.random()*40);            // 16 - 56
      obstacles.push({ x: pos, width: w, height: h, color: '#2a9d8f', passed:false });
      pos += minGap + Math.random()*(maxGap-minGap);
      if (pos > goalDistance - 100) break;
    }
  }

  // Game state
  let worldOffset = 0, lastTime = null, running = true, finished = false, crashed = false;
  let obstaclesPassed = 0, jumps = 0, startTimestamp = null, endTimestamp = null;

  const canvas = document.getElementById('game'), ctx = canvas.getContext('2d');
  const hud = document.getElementById('hud'), endLinkInput = document.getElementById('endLink');
  const saveLinkBtn = document.getElementById('saveLink'), randomizeBtn = document.getElementById('randomize');
  const fullscreenBtn = document.getElementById('fullscreen'), playAgainBtn = document.getElementById('playAgain');

  // load/save end link
  const storageKey = 'jr-end-link-v1';
  function loadEndLink(){ return localStorage.getItem(storageKey) || document.body.getAttribute('data-end-link') || 'https://example.com'; }
  function saveEndLink(v){ localStorage.setItem(storageKey, v); }

  endLinkInput.value = loadEndLink();
  saveLinkBtn.addEventListener('click', ()=>{ const v=endLinkInput.value.trim(); if(v){ saveEndLink(v); hudMessage('Saved end link'); }});

  randomizeBtn.addEventListener('click', ()=>{ generateObstacles(); hudMessage('Level randomized'); });

  fullscreenBtn.addEventListener('click', ()=>{ if(document.fullscreenElement){ document.exitFullscreen(); } else { canvas.requestFullscreen && canvas.requestFullscreen(); } });

  playAgainBtn.addEventListener('click', restart);

  function hudMessage(msg){ hud.innerText = msg; setTimeout(()=>{ if(!finished && !crashed) hud.innerText = 'Jump to avoid obstacles — Reach the flag!'; },1400); }

  // Input
  function onKey(e){
    if (e.code === 'Space' || e.code === 'ArrowUp'){ e.preventDefault(); jump(); }
    if ((e.code === 'KeyR' || e.code === 'Enter') && (finished || crashed)) restart();
  }
  function onPointer(){ jump(); }
  function jump(){
    if (!running) return;
    if (player.onGround){
      player.vy = jumpVelocity;
      player.onGround = false;
      jumps++;
      playSound('jump');
    }
  }

  function checkCollision(ob) {
    const obsScreenX = ob.x - worldOffset;
    const obsY = groundY - ob.height;
    const px = player.x, py = player.y;
    return !(px + player.width < obsScreenX || px > obsScreenX + ob.width || py + player.height < obsY || py > obsY + ob.height);
  }

  // End overlay
  function showEndOverlay(success) {
    running = false; finished = success; endTimestamp = performance.now();
    // overlay
    const overlay = document.createElement('div'); overlay.className = 'overlay';
    const card = document.createElement('div'); card.className = 'overlay-card';
    overlay.appendChild(card);
    const title = document.createElement('div'); title.style.fontSize='20px'; title.style.fontWeight='700';
    card.appendChild(title);

    const link = document.createElement('a'); link.className='big-link'; link.target='_blank'; link.rel='noopener';
    const hint = document.createElement('div'); hint.className='small'; hint.style.marginTop='10px';

    if(success){
      playSound('success');
      title.innerText = 'You reached the end!';
      link.href = loadEndLink();
      link.innerText = 'Open link';
      card.appendChild(link);
      hint.innerText = 'Press R to play again.';
    } else {
      playSound('crash');
      title.innerText = 'You crashed!';
      hint.innerText = 'Press R to try again.';
    }

    // Score details
    const scoreBox = document.createElement('div'); scoreBox.style.marginTop='12px'; scoreBox.style.fontSize='15px';
    const timeTaken = Math.max(0, Math.round((endTimestamp - startTimestamp)/1000));
    const score = obstaclesPassed*120 + Math.max(0, (targetDurationMs/1000 - timeTaken))*6 - (crashed? 80:0);
    scoreBox.innerHTML = `<div>Obstacles passed: <strong>${obstaclesPassed}</strong></div>
                          <div>Jumps: <strong>${jumps}</strong></div>
                          <div>Time: <strong>${timeTaken}s</strong></div>
                          <div style="margin-top:8px">Score: <strong>${Math.max(0, Math.round(score))}</strong></div>`;
    card.appendChild(scoreBox);
    card.appendChild(hint);

    document.body.appendChild(overlay);
    // fade
    overlay.style.background = 'rgba(0,0,0,0)';
    let t=0; function f(){ t+=0.03; overlay.style.background = `rgba(0,0,0,${Math.min(0.9,t)})`; if(t<0.9) requestAnimationFrame(f); } requestAnimationFrame(f);
  }

  function restart(){
    worldOffset = 0; lastTime = null; running = true; finished = false; crashed = false;
    obstaclesPassed = 0; jumps = 0; startTimestamp = performance.now(); endTimestamp = null;
    player.y = groundY - player.height; player.vy = 0; player.onGround = true;
    generateObstacles();
    document.querySelectorAll('.overlay').forEach(n=>n.remove());
    hud.innerText = 'Jump to avoid obstacles — Reach the flag!';
    requestAnimationFrame(loop);
  }

  // Drawing
  function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // ground
    ctx.fillStyle = '#6aa84f';
    ctx.fillRect(0, groundY, canvas.width, canvas.height-groundY);

    // parallax ground bumps
    ctx.fillStyle = '#4d7b1f';
    for (let i=0;i<6;i++){
      const gx = ((i*220) - (worldOffset*0.5 % 220) + 1000) % 220 - 60 + i*220 - 100;
      ctx.fillRect(gx, groundY-10, 120, 10);
    }

    // goal
    const goalScreenX = goalDistance - worldOffset;
    if (goalScreenX > -80 && goalScreenX < canvas.width + 80) {
      ctx.fillStyle = '#333'; ctx.fillRect(goalScreenX + 10, groundY - 100, 4, 100);
      ctx.fillStyle = '#ef476f'; ctx.beginPath(); ctx.moveTo(goalScreenX + 14, groundY - 100); ctx.lineTo(goalScreenX + 48, groundY - 86); ctx.lineTo(goalScreenX + 14, groundY - 74); ctx.closePath(); ctx.fill();
    }

    // obstacles
    for (const ob of obstacles){
      const x = Math.round(ob.x - worldOffset);
      if (x + ob.width < -40 || x > canvas.width + 40) continue;
      const y = groundY - ob.height;
      ctx.fillStyle = ob.color; roundRect(ctx, x, y, ob.width, ob.height, 6, true, false);
      ctx.fillStyle = 'rgba(0,0,0,0.12)'; ctx.fillRect(x+2, groundY-4, ob.width-4, 4);
    }

    // player
    ctx.fillStyle = player.color; roundRect(ctx, player.x, player.y, player.width, player.height, 6, true, false);
    // eye
    ctx.fillStyle = '#2d2d2d'; ctx.fillRect(player.x + (player.width>24?20:16), player.y + 10, 4, 4);

    // progress bar + timer
    const barW = 420, barH=8, bx=(canvas.width-barW)/2, by=12;
    ctx.fillStyle='rgba(255,255,255,0.6)'; ctx.fillRect(bx,by,barW,barH);
    const progress = Math.min(1, worldOffset/goalDistance);
    ctx.fillStyle='#264653'; ctx.fillRect(bx,by,barW*progress,barH);
    const remainingMs = Math.max(0, targetDurationMs * (1 - worldOffset/goalDistance)), remS = Math.ceil(remainingMs/1000);
    ctx.fillStyle='#023047'; ctx.font='bold 14px system-ui'; ctx.textAlign='center'; ctx.fillText(`Time left: ${remS}s`, canvas.width/2, by+barH+22);
  }

  function roundRect(ctx,x,y,w,h,r,fill,stroke){
    if(typeof r==='undefined') r=6; ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); if(fill) ctx.fill(); if(stroke) ctx.stroke();
  }

  // Loop
  function loop(t){
    if (!lastTime) lastTime = t;
    const dt = t - lastTime; lastTime = t;
    if(!running) return;

    worldOffset += speed * dt;

    // physics
    if (!player.onGround) {
      player.vy += gravity * dt;
      player.y += player.vy * dt;
      if (player.y >= groundY - player.height){ player.y = groundY - player.height; player.vy = 0; player.onGround = true; }
    }

    // check obstacles passing & collision
    for (const ob of obstacles){
      if(!ob.passed && worldOffset > ob.x + ob.width){
        ob.passed = true; obstaclesPassed++;
      }
      if (checkCollision(ob)) {
        crashed = true; hud.innerText = 'Crashed! Press R to restart.'; showEndOverlay(false); return;
      }
    }

    draw();

    if (worldOffset >= goalDistance){
      hud.innerText = 'You reached the goal!'; showEndOverlay(true); return;
    }

    requestAnimationFrame(loop);
  }

  // AUDIO: small effects using WebAudio (no external files)
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const audioCtx = AudioCtx ? new AudioCtx() : null;

  function playTone(freq, type='sine', dur=0.12, volume=0.12){
    if(!audioCtx) return;
    const now = audioCtx.currentTime;
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
    o.type = type; o.frequency.setValueAtTime(freq, now);
    g.gain.setValueAtTime(volume, now);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(now); o.stop(now + dur);
    g.gain.exponentialRampToValueAtTime(0.0001, now + dur);
  }
  function playSound(name){
    if(!audioCtx) return;
    // resume on first user interaction if suspended
    if(audioCtx.state==='suspended') audioCtx.resume();
    if(name==='jump'){ playTone(780,'sine',0.10,0.09); playTone(1100,'triangle',0.08,0.05); }
    if(name==='crash'){ playTone(120,'square',0.18,0.16); playTone(70,'sawtooth',0.22,0.08); }
    if(name==='success'){ playTone(880,'sine',0.12,0.12); setTimeout(()=>playTone(660,'sine',0.12,0.11),120); setTimeout(()=>playTone(990,'sine',0.18,0.14),260); }
  }

  // Init & event wiring
  generateObstacles();
  startTimestamp = performance.now();
  requestAnimationFrame(loop);

  window.addEventListener('keydown', onKey);
  canvas.addEventListener('pointerdown', onPointer);
  canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); onPointer(); }, {passive:false});

  // Accessibility: focus handlers to allow keyboard to work
  canvas.tabIndex = 0;

  // PWA: create a simple manifest and service worker dynamically (single-file)
  (function installPWA(){
    // manifest
    const manifest = {
      name: "Jump Runner",
      short_name: "JumpRunner",
      start_url: ".",
      display: "standalone",
      background_color: "#87ceeb",
      theme_color: "#0b3d91",
      icons: [{
        src: "data:image/svg+xml;base64," + btoa(`<svg xmlns='http://www.w3.org/2000/svg' width='192' height='192'><rect width='100%' height='100%' fill='#1f6feb'/><circle cx='96' cy='72' r='30' fill='#ffb703'/></svg>`),
        sizes: "192x192",
        type: "image/svg+xml"
      }]
    };
    const manifestBlob = new Blob([JSON.stringify(manifest)], {type:'application/json'});
    const manifestURL = URL.createObjectURL(manifestBlob);
    let link = document.querySelector('link[rel="manifest"]');
    if(!link){ link = document.createElement('link'); link.rel='manifest'; document.head.appendChild(link); }
    link.href = manifestURL;

    // service worker (very small, caches the single HTML on install)
    if('serviceWorker' in navigator){
      const swCode = `
        const CACHE = 'jr-cache-v1';
        self.addEventListener('install', e => { self.skipWaiting(); e.waitUntil(caches.open(CACHE).then(c=>c.addAll(['./']))); });
        self.addEventListener('activate', e => { e.waitUntil(self.clients.claim()); });
        self.addEventListener('fetch', e => {
          e.respondWith(caches.match(e.request).then(r => r || fetch(e.request)));
        });
      `;
      try {
        const swBlob = new Blob([swCode], {type:'text/javascript'});
        const swURL = URL.createObjectURL(swBlob);
        navigator.serviceWorker.register(swURL).catch(()=>{/* ignore */});
      } catch(e) { /* ignore on file:// or restricted origins */ }
    }
  })();

  // expose restart
  window.restartRunner = restart;
})();
</script>
</body>
</html>